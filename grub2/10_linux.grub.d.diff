diff --git a/etc/grub.d/10_linux.dpkg-zfs b/grub2/10_linux
index 893b0c9..689b594 100755
--- a/etc/grub.d/10_linux.dpkg-zfs
+++ b/grub2/10_linux
@@ -51,6 +51,7 @@ else
   LINUX_ROOT_DEVICE=UUID=${GRUB_DEVICE_UUID}
 fi
 
+if [ "x${GRUB_DEVICE}" != "zfs" ] ; then
 if [ "x`${grub_probe} --device ${GRUB_DEVICE} --target=fs 2>/dev/null || true`" = xbtrfs ]; then
   rootsubvol="`make_system_path_relative_to_its_root /`"
   rootsubvol="${rootsubvol#/}"
@@ -58,6 +59,56 @@ if [ "x`${grub_probe} --device ${GRUB_DEVICE} --target=fs 2>/dev/null || true`"
     GRUB_CMDLINE_LINUX="rootflags=subvol=${rootsubvol} ${GRUB_CMDLINE_LINUX}"
   fi
 fi
+fi
+
+detect_zfs()
+{
+
+  rel_dirname=
+  if [ "${GRUB_DEVICE}" = "zfs" ] ; then
+        # let's look up the root dataset based on zfs mount
+        rootdataset=`zfs mount | awk ' $2 == "/" { print $1 } ' | tail -1`
+        # now let's inspect the pool that contains the mounted / for a bootfs property
+        rootpool=`echo "$rootdataset" | sed 's|/.*||'`
+	rootfs=`zpool get bootfs "$rootpool" | awk ' { print $3 } ' | tail -1`
+        # if there is no bootfs property, simply use the root dataset
+	if [ "x$rootfs" = "x-" ] ; then
+          LINUX_ROOT_DEVICE="ZFS=$rootdataset" # FIXME escape spaces
+        else
+          LINUX_ROOT_DEVICE="zfs" # automatic dracut pickup dataset by bootfs property
+        fi
+  fi
+
+  if [ "${GRUB_DEVICE_BOOT}" = "zfs" ] ; then
+    if [ x$dirname = x/ ] ; then
+        rootdataset=`zfs mount | awk ' $2 == "/" { print $1 } ' | tail -1`
+        # now let's inspect the pool that contains the mounted / for a bootfs property
+        rootpool=`echo "$rootdataset" | sed 's|/.*||'`
+	rootfs=`zpool get bootfs "$rootpool" | awk ' { print $3 } ' | tail -1`
+	rootdatasetnopool=$(echo -E "$rootdataset" | sed 's|^[^/]*/|/|')
+        rel_dirname="$rootdatasetnopool/@/boot"
+	rootdevice=/dev/`sudo zpool iostat -v "$rootpool" | grep '^  ' | grep -v "^   " | awk ' { print $1 } '`
+	rootdevicegrub=$(${grub_probe} --device "$rootdevice" --target=drive)
+        prepare_root_cache="	insmod zfs
+	set root='$rootdevicegrub'
+	insmod zfsinfo
+	zfs-bootfs (\$root) bootfs"
+    else
+        # first, let's see if we can find something mounted on /boot
+        bootdataset=`zfs mount | awk ' $2 == "/boot" { print $1 } ' | tail -1`
+        bootpool=`echo "$bootdataset" | sed 's|/.*||'`
+	bootdatasetnopool=$(echo -E "$bootdataset" | sed 's|^[^/]*/|/|')
+        rel_dirname="$bootdatasetnopool/@"
+	bootdevice=/dev/`sudo zpool iostat -v "$bootpool" | grep '^  ' | grep -v "^   " | awk ' { print $1 } '`
+	bootdevicegrub=$(${grub_probe} --device "$bootdevice" --target=drive)
+        prepare_boot_cache="	insmod zfs
+	set root='$bootdevicegrub'
+	insmod zfsinfo
+	zfs-bootfs (\$root) bootfs"
+    fi
+  fi
+
+}
 
 linux_entry ()
 {
@@ -149,7 +200,9 @@ while [ "x$list" != "x" ] ; do
   echo "Found linux image: $linux" >&2
   basename=`basename $linux`
   dirname=`dirname $linux`
+  detect_zfs ; if [ -z "$rel_dirname" ] ; then
   rel_dirname=`make_system_path_relative_to_its_root $dirname`
+  fi
   version=`echo $basename | sed -e "s,^[^0-9]*-,,g"`
   alt_version=`echo $version | sed -e "s,\.old$,,g"`
   linux_root_device_thisversion="${LINUX_ROOT_DEVICE}"
