#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#

#
# Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#

#
# Copyright (c) 2013, 2015 by Delphix. All rights reserved.
#

. $STF_SUITE/include/libtest.shlib
. $STF_SUITE/tests/functional/hole_birth/hole_birth.cfg

#
# Set up test model which includes various datasets
#
#               @final
#               @snapB
#               @init
#               |
#   ______ pclone
#  |      /
#  |@psnap
#  ||                         @final
#  ||@final       @final      @snapC
#  ||@snapC       @snapC      @snapB
#  ||@snapA       @snapB      @snapA
#  ||@init        @init       @init
#  |||            |           |
# $pool -------- $FS ------- fs1 ------- fs2
#    \             \\_____     \          |
#     vol           vol   \____ \         @fsnap
#      |              |        \ \              \
#      @init          @vsnap   |  ------------ fclone
#      @snapA         @init \  |                    |
#      @final         @snapB \ |                    @init
#                     @snapC  vclone                @snapA
#                     @final       |                @final
#                                 @init
#                                 @snapC
#                                 @final
#
# $1 pool name
#
function setup_test_model
{
	typeset pool=$1

	return 0
}

#
# Cleanup the BACKDIR and given pool content and all the sub datasets
#
# $1 pool name
#
function cleanup_pool
{
	typeset pool=$1
	log_must $RM -rf $BACKDIR/*

	if is_global_zone ; then
		log_must $ZFS destroy -Rf $pool
	else
		typeset list=$($ZFS list -H -r -t filesystem,snapshot,volume -o name $pool)
		for ds in $list ; do
			if [[ $ds != $pool ]] ; then
				if datasetexists $ds ; then
					log_must $ZFS destroy -Rf $ds
				fi
			fi
		done
	fi

	typeset mntpnt=$(get_prop mountpoint $pool)
	if ! ismounted $pool ; then
		# Make sure mountpoint directory is empty
		if [[ -d $mntpnt ]]; then
			log_must $RM -rf $mntpnt/*
		fi

		log_must $ZFS mount $pool
	fi
	if [[ -d $mntpnt ]]; then
		log_must $RM -rf $mntpnt/*
	fi

	return 0
}

function cmp_md5s {
	typeset file1=$1
	typeset file2=$2

	eval md5sum $file1 | awk '{ print $1 }'	> $BACKDIR/md5_file1
	eval md5sum $file2 | awk '{ print $1 }'	> $BACKDIR/md5_file2
	$DIFF $BACKDIR/md5_file1 $BACKDIR/md5_file2
        typeset -i ret=$?

        $RM -f $BACKDIR/md5_file1 $BACKDIR/md5_file2

        return $ret

}

#
# Detect if the given two filesystems have same sub-datasets
#
# $1 source filesystem
# $2 destination filesystem
#
function cmp_ds_subs
{
	typeset src_fs=$1
	typeset dst_fs=$2

	$ZFS list -r -H -t filesystem,snapshot,volume -o name $src_fs > $BACKDIR/src1
	$ZFS list -r -H -t filesystem,snapshot,volume -o name $dst_fs > $BACKDIR/dst1

	eval $SED -e 's:^$src_fs:PREFIX:g' < $BACKDIR/src1 > $BACKDIR/src
	eval $SED -e 's:^$dst_fs:PREFIX:g' < $BACKDIR/dst1 > $BACKDIR/dst

	$DIFF $BACKDIR/src $BACKDIR/dst
	typeset -i ret=$?

	$RM -f $BACKDIR/src $BACKDIR/dst $BACKDIR/src1 $BACKDIR/dst1

	return $ret
}

#
# Compare all the directores and files in two filesystems
#
# $1 source filesystem
# $2 destination filesystem
#
function cmp_ds_cont
{
	typeset src_fs=$1
	typeset dst_fs=$2

	typeset srcdir dstdir
	srcdir=$(get_prop mountpoint $src_fs)
	dstdir=$(get_prop mountpoint $dst_fs)

	$DIFF -r $srcdir $dstdir > /dev/null 2>&1
	echo $?
}

#
# Compare the given two dataset properties
#
# $1 dataset 1
# $2 dataset 2
#
function cmp_ds_prop
{
	typeset dtst1=$1
	typeset dtst2=$2

	for item in "type" "origin" "volblocksize" "aclinherit" "acltype" \
	    "atime" "canmount" "checksum" "compression" "copies" "devices" \
	    "dnodesize" "exec" "quota" "readonly" "recordsize" "reservation" \
	    "setuid" "snapdir" "version" "volsize" "xattr" "zoned" \
	    "mountpoint";
	do
		$ZFS get -H -o property,value,source $item $dtst1 >> \
		    $BACKDIR/dtst1
		$ZFS get -H -o property,value,source $item $dtst2 >> \
		    $BACKDIR/dtst2
	done

	eval $SED -e 's:$dtst1:PREFIX:g' < $BACKDIR/dtst1 > $BACKDIR/dtst1
	eval $SED -e 's:$dtst2:PREFIX:g' < $BACKDIR/dtst2 > $BACKDIR/dtst2

	$DIFF $BACKDIR/dtst1 $BACKDIR/dtst2
	typeset -i ret=$?

	$RM -f $BACKDIR/dtst1 $BACKDIR/dtst2

	return $ret

}

#
# Random create directories and files
#
# $1 directory
#
function random_tree
{
	typeset dir=$1

	if [[ -d $dir ]]; then
		$RM -rf $dir
	fi
	$MKDIR -p $dir
	typeset -i ret=$?

	typeset -i nl nd nf
	((nl = RANDOM % 6 + 1))
	((nd = RANDOM % 3 ))
	((nf = RANDOM % 5 ))
	$MKTREE -b $dir -l $nl -d $nd -f $nf
	((ret |= $?))

	return $ret
}

#
# Put data in filesystem and take snapshot
#
# $1 snapshot name
#
function snapshot_tree
{
	typeset snap=$1
	typeset ds=${snap%%@*}
	typeset type=$(get_prop "type" $ds)

	typeset -i ret=0
	if [[ $type == "filesystem" ]]; then
		typeset mntpnt=$(get_prop mountpoint $ds)
		((ret |= $?))

		if ((ret == 0)) ; then
			eval random_tree $mntpnt/${snap##$ds}
			((ret |= $?))
		fi
	fi

	if ((ret == 0)) ; then
		$ZFS snapshot $snap
		((ret |= $?))
	fi

	return $ret
}

#
# Destroy the given snapshot and stuff
#
# $1 snapshot
#
function destroy_tree
{
	typeset -i ret=0
	typeset snap
	for snap in "$@" ; do
		$ZFS destroy $snap
		ret=$?

		typeset ds=${snap%%@*}
		typeset type=$(get_prop "type" $ds)
		if [[ $type == "filesystem" ]]; then
			typeset mntpnt=$(get_prop mountpoint $ds)
			((ret |= $?))

			if ((ret != 0)); then
				$RM -r $mntpnt/$snap
				((ret |= $?))
			fi
		fi

		if ((ret != 0)); then
			return $ret
		fi
	done

	return 0
}

#
# Setup filesystems for the resumable send/receive tests
#
# $1 The pool to set up with the "send" filesystems
# $2 The pool for receive
#
function test_fs_setup_4809
{
	sendpool=$1
	recvpool=$2

	sendfs=$sendpool/sendfs
	recvfs=$recvpool/recvfs

	if datasetexists $recvfs; then
		log_must $ZFS destroy -r $recvfs
	fi
	if datasetexists $sendfs; then
		log_must $ZFS destroy -r $sendfs
	fi
	if $($ZFS create -o recordsize=4k $sendfs); then
		# initial create
		log_must truncate -s 1G /$sendfs/file1
		log_must dd if=/dev/urandom of=/$sendfs/file1 bs=4k count=11264 seek=1152
		sleep 5

		log_must $ZFS snapshot $sendfs@snap1

		# permute
		log_must truncate -s 4194304 /$sendfs/file1
		log_must dd if=/dev/urandom of=/$sendfs/file1 bs=4k count=152 seek=384 conv=notrunc
		sleep 5
		log_must dd if=/dev/urandom of=/$sendfs/file1 bs=4k count=10 seek=1408 conv=notrunc
		sleep 5

		log_must $ZFS snapshot $sendfs@snap2
		log_must eval "$ZFS send -v $sendfs@snap1 >/$sendpool/initial.zsend"
		log_must eval "$ZFS send -v -i @snap1 $sendfs@snap2 " \
		    ">/$sendpool/incremental.zsend"
	fi

}

function test_fs_setup_4809_1
{
	sendpool=$1
	recvpool=$2

	sendfs=$sendpool/sendfs
	recvfs=$recvpool/recvfs

	if datasetexists $recvfs; then
		log_must $ZFS destroy -r $recvfs
	fi
	if datasetexists $sendfs; then
		log_must $ZFS destroy -r $sendfs
	fi
	if $($ZFS create -o recordsize=4k $sendfs); then
		# initial create
		log_must truncate -s 1G /$sendfs/file1
		log_must dd if=/dev/urandom of=/$sendfs/file1 bs=4k count=11264 seek=1152

		log_must $ZFS snapshot $sendfs@snap1

		# permute
		log_must truncate -s 4194304 /$sendfs/file1
		log_must dd if=/dev/urandom of=/$sendfs/file1 bs=4k count=152 seek=384 conv=notrunc
		log_must dd if=/dev/urandom of=/$sendfs/file1 bs=4k count=10 seek=1408 conv=notrunc

		log_must $ZFS snapshot $sendfs@snap2
		log_must eval "$ZFS send -v $sendfs@snap1 >/$sendpool/initial.zsend"
		log_must eval "$ZFS send -v -i @snap1 $sendfs@snap2 " \
		    ">/$sendpool/incremental.zsend"
	fi

}

#
# Setup filesystems for the resumable send/receive tests
#
# $1 The pool to set up with the "send" filesystems
# $2 The pool for receive
#
function test_fs_setup_4996
{
	sendpool=$1
	recvpool=$2

	sendfs=$sendpool/sendfs
	recvfs=$recvpool/recvfs

	if datasetexists $recvfs; then
		log_must $ZFS destroy -r $recvfs
	fi
	if datasetexists $sendfs; then
		log_must $ZFS destroy -r $sendfs
	fi
	if $($ZFS create -o recordsize=512 $sendfs); then
		# initial create
		log_must dd if=/dev/urandom of=/$sendfs/file1 bs=128k count=1 seek=1
		sleep 5

		log_must $ZFS snapshot $sendfs@snap1

		# permute
		log_must dd if=/dev/urandom of=/$sendfs/file1 bs=128k count=1
		sleep 5
		log_must dd if=/dev/urandom of=/$sendfs/file1 bs=128k count=1 seek=3
		sleep 5

		log_must $ZFS snapshot $sendfs@snap2
		log_must eval "$ZFS send -v $sendfs@snap1 >/$sendpool/initial.zsend"
		log_must eval "$ZFS send -v -i @snap1 $sendfs@snap2 " \
		    ">/$sendpool/incremental.zsend"
	fi

}

#
# Setup filesystems for the resumable send/receive tests
#
# $1 The pool to set up with the "send" filesystems
# $2 The pool for receive
#
function test_fs_setup_5030
{
	sendpool=$1
	recvpool=$2

	sendfs=$sendpool/sendfs
	recvfs=$recvpool/recvfs

	if datasetexists $recvfs; then
		log_must $ZFS destroy -r $recvfs
	fi
	if datasetexists $sendfs; then
		log_must $ZFS destroy -r $sendfs
	fi
	if $($ZFS create -o recordsize=4k $sendfs); then
		# initial create
		log_must truncate -s 1G /$sendfs/file1
		log_must dd if=/dev/urandom of=/$sendfs/file1 bs=4k count=11264 seek=1152
		sleep 5

		log_must $ZFS snapshot $sendfs@snap1

		# permute
		log_must truncate -s 4194304 /$sendfs/file1
		log_must dd if=/dev/urandom of=/$sendfs/file1 bs=4k count=152 seek=384 conv=notrunc
		sleep 5
		log_must dd if=/dev/urandom of=/$sendfs/file1 bs=4k count=10 seek=1408 conv=notrunc
		sleep 5

		log_must $ZFS snapshot $sendfs@snap2
		log_must eval "$ZFS send -v $sendfs@snap1 >/$sendpool/initial.zsend"
		log_must eval "$ZFS send -v -i @snap1 $sendfs@snap2 " \
		    ">/$sendpool/incremental.zsend"
	fi

}

#
# Setup filesystems for the resumable send/receive tests
#
# $1 The pool to set up with the "send" filesystems
# $2 The pool for receive
#
function test_fs_setup_7176
{
	sendpool=$1
	recvpool=$2

	sendfs=$sendpool/sendfs
	recvfs=$recvpool/recvfs

	if datasetexists $recvfs; then
		log_must $ZFS destroy -r $recvfs
	fi
	if datasetexists $sendfs; then
		log_must $ZFS destroy -r $sendfs
	fi
	if $($ZFS create -o recordsize=512 $sendfs); then
		# initial create
		log_must truncate --size=300M /$sendfs/file1
#		log_must dd if=/dev/urandom of=/$sendfs/file1 bs=512 count=128k conv=notrunc
#		sleep 5

		log_must $ZFS snapshot $sendfs@snap1

		log_must truncate --size=10M /$sendfs/file1
		sleep 5

		# permute
		log_must dd if=/dev/urandom of=/$sendfs/file1 bs=512 count=1 seek=96k conv=notrunc
		sleep 5

		log_must $ZFS snapshot $sendfs@snap2
		log_must eval "$ZFS send -v $sendfs@snap1 >/$sendpool/initial.zsend"
		log_must eval "$ZFS send -v -i @snap1 $sendfs@snap2 " \
		    ">/$sendpool/incremental.zsend"
	fi

}
